#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass book
\use_default_options true
\begin_modules
eqs-within-sections
figs-within-sections
theorems-ams
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
\begin_inset CommandInset label
LatexCommand label
name "cha:Snippets-and-SiteMap"

\end_inset

Snippets y SiteMap
\end_layout

\begin_layout Standard
Lift sirve las peticiones HTTP de tres maneras: generando páginas HTML,
 respuestas HTTP de bajo nivel(e.j.
 REST), y respondiendo a peticiones Ajax/Comet.
 Lift trata cada tipo de petición de diferente manera para hacer que la
 semantica de respuesta para cada tipo de petición se más natural.
 Dicho de otra manera, es diferente construir una página HTML compleja con
 un montón de diferentes componentes que enviar de vuelta algunos datos
 JSON que corresponden a algún registro de base de datos.
\end_layout

\begin_layout Standard
En este capítulo se explorará como Lift realizá la generación dinámica de
 páginas HTML en base a la petición HTTP entrante, incluyendo el hecho de
 poner 
\begin_inset Quotes eld
\end_inset

cromo
\begin_inset Quotes erd
\end_inset

 alrededor de la página HTML(menus, etc.), colocando contenido dinámico en
 cada página, y navegación del sitio, incluso control de acceso.
\end_layout

\begin_layout Standard
El código de este capítulo se encuentra en el directorio 
\family typewriter
samples/snippet_and_sitemap 
\family default
de la 
\begin_inset CommandInset href
LatexCommand href
name "distribución"
target "https://github.com/dpp/simply_lift/tarball/master"

\end_inset

 de 
\emph on
Simply Lift
\emph default
.
\end_layout

\begin_layout Section
Empezando por el principio: 
\family typewriter
Boot.scala
\end_layout

\begin_layout Standard
Cuando una aplicación Lift arranca, se ejecuta el código que se encuentra
 en Boot.scala:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "src/main/scala/bootstrap/liftweb/Boot.scala"
lstparams "caption={Boot.scala}"

\end_inset


\end_layout

\begin_layout Standard
En lugar de mantener parámetros de configuración en archivos XML, Lift mantiene
 los parámetros de configuración en código dentro de 
\family typewriter
Boot
\family default
.
 Boot se ejecuta una sola vez cuando el contenedor de servlets carga la
 aplicación Lift.
 Se puede cambiar muchas de las reglas de ejecución de Lift que se encuentran
 dentro del singleton 
\family typewriter
LiftRules
\family default
 durante el arranque, pero luego del arranque, estos parámetros estan congelados.
\end_layout

\begin_layout Subsection
Reglas
\family typewriter
 LiftRules
\end_layout

\begin_layout Standard
La mayoría de los parámetros de configuración que definen como Lift convertirá
 una petición HTPP en una respuesta estan contenidas en el singleton 
\family typewriter
LiftRules
\family default
.
 Algunos parámtros de 
\family typewriter
LiftRules
\family default
 son usados comunmente y algunos son muy rara vez cambiados de su comportamiento
 por defecto.
 LiftRules puede ser cambiado durante el arranque, pero no en otro tiempo.
 Entonces, se debe poner todas la configuraciones en boot(o en métodos que
 son llamados desde boot).
\end_layout

\begin_layout Subsection
Propiedades y modos de ejecución
\end_layout

\begin_layout Standard
Mientras muchas de las propiedades para la aplicación pueden ser definidas
 en 
\family typewriter
Boot.scala
\family default
, existen algunas propiedades que es mejor definirlas en un archivo de texto.
 Lift soporta multiples archivos de propiedades por proyecto.
 Los archivos de propiedades son cargados en base al usuario, máquina, y
 modo de ejecución.
\end_layout

\begin_layout Standard
Si se quiere proveer un archivo de configuración para un subconjunto de
 la aplicación o para un entorno en específico, Lift espera que los nombres
 de los archivos esten relacionados de alguna manera al contexto donde estan
 siendo usados.
 El formato estandar es:
\end_layout

\begin_layout Standard

\family typewriter
modeDeEjecucion.nombreDeUsuario.nombreDeHost.props
\end_layout

\begin_layout Standard
ejemplos:
\family typewriter

\begin_inset Newline newline
\end_inset

dpp.yak.props
\begin_inset Newline newline
\end_inset

test.dpp.yak.props
\begin_inset Newline newline
\end_inset

production.moose.props
\begin_inset Newline newline
\end_inset

staging.dpp.props
\begin_inset Newline newline
\end_inset

test.default.props
\begin_inset Newline newline
\end_inset

default.props
\end_layout

\begin_layout Standard
nombreDeHost y nombreDeUsuario son opcionales, y el modoDeEjecucion debe
 ser "test", "staging", "production", "pilot", "profile", o en blanco (para
 modo de desarrollo).
 La extensión estándar para archivos de propiedades en Lift es "props".
\end_layout

\begin_layout Standard
Se debe colocar los archivos de propiedades en el directorio 
\family typewriter
src/main/resources/props
\family default
 del proyecto y estos serán empaquetados como parte del proceso de construcción.
\end_layout

\begin_layout Standard
Cuando se esta desarrollando la aplicación Lift, el modo de ejecución (see
 
\family typewriter
net.liftweb.util.Props.mode
\family default
) será 
\family typewriter
Development
\family default
.
 Cuando se hace un despliegue(deploy) de la aplicación, se pasa 
\family typewriter
-Drun.mode=production
\family default
 al contenedor web.
 En modo de producción(production mode), Lift hace un cache agresivo de
 las plantillas, clases de snippets, etc.
\end_layout

\begin_layout Subsection
Por convención
\end_layout

\begin_layout Standard
Lift, como Rails, buscará por conveción items en ciertas ubicaciones.
 Por ejemplo, Lift buscará clases que implementan snippets en el paquete
 
\family typewriter
xxx.snippet
\family default
 donde xxx es el paquete principal de la aplicación.
 Se define uno o más paquetes en los que Lift buscará snippets usando:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

    // Donde buscar snippet
\end_layout

\begin_layout Plain Layout

    LiftRules.addToPackages("code")
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Aquí, se ha añadido el paquede 
\family typewriter
code
\family default
 a la lista de paquetes dentro de los que Lift buscará.
 También se puede hacer 
\family typewriter
LiftRules.addToPackages("com.fruitbat.mydivision.myapplication")
\family default
.
\end_layout

\begin_layout Subsection
Misc Rules
\end_layout

\begin_layout Standard
Se saltarña la definición de sitemap hasta la siguiente sección.
 La regla a continuación define como mostrar un ícono que gira durante las
 llamadas Ajax (Lift mostrará automaticamente el icono giratorio si esta
 función está habilitada):
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

    //Muestra un ícono que gira cuando una llamada Ajax se inicia
\end_layout

\begin_layout Plain Layout

    LiftRules.ajaxStart =
\end_layout

\begin_layout Plain Layout

      Full(() => LiftRules.jsArtifacts.show("ajax-loader").cmd)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Y esta regla coloca como codificación de carácteres por defecto a UTF-8
 en lugar de la codificación por defecto de la plataforma:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

    // Obliga que las solicitudes sean UTF-8
\end_layout

\begin_layout Plain Layout

    LiftRules.early.append(_.setCharacterEncoding("UTF-8"))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Okay...
 ya se tiene una idea...
 existen muchos parámetros que se pueden poner a punto durante el arranque.
\end_layout

\begin_layout Subsection
Html5
\end_layout

\begin_layout Standard
Antes de Lift 2.2, Lift Lift trata todos las plantillas como XHTML y emite
 XHTML al navegador.
 Cuando el proyecto Lift se inicio a principios del 2007, esto parecía una
 Muy Buena Idea™.
 Resulta que el mundo no ha apodtado XHTML y que algunas bibliotecas, por
 ejemplo Google Maps, no funcionan con páginas XHTML.
 Lift 2.2 introduce soporte opcional de Html5 tanto en el parser (para que
 asi pueda leer plantillas Html5 en lugar de requerir plantillas XML bien
 formadas) y emite Html5 al navegador.
 Lift todavía procesa las páginas como elementos 
\family typewriter
NodeSeq
\family default
 de Scala, por lo que no ser requieren cambios en la aplicación.
\end_layout

\begin_layout Standard
En orden de mantener compatibles hacia atras con el soporte XHTML de Lift,
 por defecto se usa el parser/serializer XHTML.
 Sin embargo, se recomienda usar el soporte Html5, que puede ser activa
 en el boot usando:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

    // Usar HTML5 para el renderizado
\end_layout

\begin_layout Plain Layout

    LiftRules.htmlProperties.default.set((r: Req) =>
\end_layout

\begin_layout Plain Layout

      new Html5Properties(r.userAgent))  
\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:SiteMap-1"

\end_inset


\family typewriter
SiteMap
\end_layout

\begin_layout Standard
Lift tiene una caracterísitca opcional llamada SiteMap.
 No es necesario usarla.
 Pero si se coloca un sitemap en el boot, entonces Lift usa el sitemap como
 una lista blanca de páginas HTML para el sitio (notar que las URLs REST
 no necesitan estar listadas en el sitemap).
 El SiteMap define la navegación y control de acceso, permite la creación
 de menués jerarquicos, agrupar los elementos del menú, mostrar el sitemap
 completo, un sitemap relativo, como también migas de pan.
 En esta sección se discutirán algunas de las capacidades del SiteMap.
\end_layout

\begin_layout Subsection

\family typewriter
Definir el mapa del sitio
\end_layout

\begin_layout Standard
El SiteMap debe ser definido en el boot y solamente una vez
\begin_inset Foot
status open

\begin_layout Plain Layout
En modo de desarrollo, el sitemap puede ser cambiado dinamicamente para
 soportar cambios en el contendio del sitio sin tener que reiniciar tu aplicacio
n cada vez que la navegación cambie.
 Esta es una característica que solo esta disponible en tiempo de desarrollo.
 Existen sanciones significativas en el rendimiento asocidadas a la reconstrucci
ón del sitemap en cada carga de página, incluyendo el obligar la serialización
 al servir páginas.
 Existen muchas características en el SiteMap que permiten habilitar/deshabilita
r items del menú y tener submenués dinamicamente generados.
 No hay que basarse en el modo de desarrollo (development-mode) de Lift
 para diseñar una aplicación.
\end_layout

\end_inset

.
 Típicamente, se define una función que devuelve una instancia de SiteMap:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

    // Construir el SiteMap
\end_layout

\begin_layout Plain Layout

    def sitemap(): SiteMap = ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Y después se define el 
\family typewriter
SiteMap
\family default
 en 
\family typewriter
LiftRules
\family default
:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

    // Se establece el sitemap.
  Nota, si no se quiere tener control de acceso
\end_layout

\begin_layout Plain Layout

	// para cada página comenta esta linea
\end_layout

\begin_layout Plain Layout

    LiftRules.setSiteMapFunc(() => sitemap())
\end_layout

\end_inset


\end_layout

\begin_layout Standard
En modo de desarrollo, la función será llamada para reconstruir el SiteMap
 cada vez que una página se cargueI.
 En todos los otros modos de ejecución, el sitemap solo será reconstruido
 una sola vez durante el arranque.
\end_layout

\begin_layout Standard
Un 
\family typewriter
SiteMap
\family default
 es una colección de instancias de 
\family typewriter
Menu
\family default
.
 Cada 
\family typewriter
Menu
\family default
 tiene un 
\family typewriter
Loc[_]
\family default
 y un conjutno de instancias de 
\family typewriter
Menu
\family default
 como submenués (cero o más).
 Cada instancia de 
\family typewriter
Menu
\family default
 tiene un nombre único.
\end_layout

\begin_layout Standard
Si una página HTML no esta definida en el sitemap, Lift no la servirá.
 El SiteMap es una lista blanca de páginas a servir.
 Adicionalmente, el 
\family typewriter
Loc[_]
\family default
 tiene parámetros que pueden incluir múltiples reglas de control de acceso.
\end_layout

\begin_layout Subsection
El 
\family typewriter
SiteMap más simple
\end_layout

\begin_layout Standard
El sitemap más simple define una sola página:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

    def sitemap(): SiteMap = SiteMap(Menu.i("Home") / "index")
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Este es un SiteMap con un solo item de menú.
 El Menú tiene el nombre 
\begin_inset Quotes eld
\end_inset

Home
\begin_inset Quotes erd
\end_inset

 y será mostrado localizadamente como (ver 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Localization"

\end_inset

) cadena 
\begin_inset Quotes eld
\end_inset

Home
\begin_inset Quotes erd
\end_inset

.
 El método Menu.i genera un 
\family typewriter
Menu
\family default
 con un 
\family typewriter
Loc[Unit]
\family default
.
\end_layout

\begin_layout Subsection

\family typewriter
Menu
\family default
 y 
\family typewriter
Loc[_]
\end_layout

\begin_layout Standard
Es posible que se pregunte por qué un 
\family typewriter
Menu
\family default
 y un 
\family typewriter
Loc[_]
\family default
 (abreviación de location, pronunciado 
\begin_inset Quotes eld
\end_inset

Loke
\begin_inset Quotes erd
\end_inset

) estan separados y por qué el Loc recibe un parámetro de tipo.
\end_layout

\begin_layout Standard
Un 
\family typewriter
Menu
\family default
 contiene un location y varios submenús.
 La idea original era que uno podía tener un solo 
\family typewriter
Loc[_]
\family default
 que podía ser puesto en distintos lugares en una jerarquía de menú.
 Entonces, historicamente estan separados, pero existe realmente una relación
 de uno a uno entre ellos.
\end_layout

\begin_layout Standard
El 
\family typewriter
Loc[_]
\family default
 recibe un parámetro de tipo, que define un valor actual para el 
\family typewriter
Loc
\family default
.
 Por ejemplo, si el 
\family typewriter
Loc
\family default
 referencia a una página que mostrara una página wiki, entonces el parámetro
 de tipo del 
\family typewriter
Loc
\family default
 será 
\family typewriter
WikiPage
\family default
: 
\family typewriter
Loc[WikiPage]
\family default
.
\end_layout

\begin_layout Standard
Cada 
\family typewriter
Loc
\family default
 puede tener varios parámetros (conocidos como 
\family typewriter
LocParam
\family default
, 
\begin_inset Quotes eld
\end_inset

loke param
\begin_inset Quotes erd
\end_inset

) que definen el comportamiento del 
\family typewriter
Loc[_]
\family default
.
 Estos parámetros incluyen acceso a las pruebas de control, definición de
 plantillas, título, grupo, etc.
\end_layout

\begin_layout Subsection
Control de Acceso
\end_layout

\begin_layout Standard
Se puede controlar el acceso a un URL/página representada por el 
\family typewriter
Loc
\family default
 con el LocParam 
\family typewriter
If()
\family default
:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

  /**
\end_layout

\begin_layout Plain Layout

   * Calcula si la página debería ser mostrada.
\end_layout

\begin_layout Plain Layout

   * En este caso, será visible cada minuto
\end_layout

\begin_layout Plain Layout

   */
\end_layout

\begin_layout Plain Layout

  def displaySometimes_? : Boolean = 
\end_layout

\begin_layout Plain Layout

    (millis / 1000L / 60L) % 2 == 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      Menu.i("Sometimes") / "sometimes" >> If(displaySometimes_? _,
\end_layout

\begin_layout Plain Layout

                                            S ? "Can't view now")
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We define a method that returns 
\family typewriter
true
\family default
 if access is allowed.
 Adding the 
\family typewriter
If()
\family default
 
\family typewriter
LocParam
\family default
 will restrict access to the page unless the function returns true.
 Menu items will not be visible for pages that do not pass the access control
 rules and even if the user types the URL into the browser, the page will
 not be displayed (by default, the user will be redirected by to the home
 page and an error will be displayed.)
\end_layout

\begin_layout Subsection

\family typewriter
Hidden
\family default
 y 
\family typewriter
Group
\end_layout

\begin_layout Standard
Los items de Menu, pueden ser ocultados de la jerarquia por defecto incluso
 si la página es accesible.
 El LocParam Hidden dice 
\begin_inset Quotes eld
\end_inset

oculta del menu por defecto.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

 Menu.i("About") / "about" >> Hidden >> LocGroup("bottom")
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Los items de Menu pueden ser tambien agrupados en grupos con nombre y despues
 pueden ser visualizados:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=xml"
inline false
status open

\begin_layout Plain Layout

 <span class="lift:Menu.group?group=bottom"></span>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Que se traduce en:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=xml"
inline false
status open

\begin_layout Plain Layout

 <a href="/about">About</a> <a href="/feedback">Feedback</a> <a href="/sitemap">
Sitemap</a> 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Submenus
\end_layout

\begin_layout Standard
Se puede anidar menús:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

      // Un menú con submenús
\end_layout

\begin_layout Plain Layout

      Menu.i("Info") / "info" submenus(
\end_layout

\begin_layout Plain Layout

        Menu.i("About") / "about" >> Hidden >> LocGroup("bottom"),
\end_layout

\begin_layout Plain Layout

        Menu.i("Contact") / "contact",
\end_layout

\begin_layout Plain Layout

        Menu.i("Feedback") / "feedback" >> LocGroup("bottom"))
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Las páginas About, Contact y Feedback estan anidadas dentro de la página
 Infor.
\end_layout

\begin_layout Subsection
Parámetros
\end_layout

\begin_layout Standard
Se puede parsear la URL entrante y extraer parametros de ella en variables
 de tipo seguro:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// captura la información de parámetros de la página
\end_layout

\begin_layout Plain Layout

case class ParamInfo(theParam: String)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Crea un menú para /param/somedata
\end_layout

\begin_layout Plain Layout

  val menu = Menu.param[ParamInfo]("Param", "Param", 
\end_layout

\begin_layout Plain Layout

                                   s => Full(ParamInfo(s)), 
\end_layout

\begin_layout Plain Layout

                                   pi => pi.theParam) / "param"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El código anterior crea un menú llamado 
\begin_inset Quotes eld
\end_inset

Param
\begin_inset Quotes erd
\end_inset

.
 El menú es para la url
\family typewriter
 /param/xxx
\family default
 donde 
\family typewriter
xxx
\family default
 puede enparejar con cualquier cosa.
\end_layout

\begin_layout Standard
Cuando la URL 
\family typewriter
/param/dogfood
\family default
 o 
\family typewriter
/param/fruitbat
\family default
 se presenta, empareja con el 
\family typewriter
Loc
\family default
 y la función (
\family typewriter
s => Full(ParamInfo(s))
\family default
) es invocada.
 Si devuelve un 
\family typewriter
Full
\family default
 
\family typewriter
Box
\family default
, el valor es colocado en el valor actual del 
\family typewriter
Loc
\family default
.
\end_layout

\begin_layout Standard
Es posible escribir a mano una implementación de Loc que emparejara con
 muchos parámetros de URL.
\end_layout

\begin_layout Standard
Para información sobre acceso a los parámetros capturados (en este caso
 
\family typewriter
ParamInfo
\family default
), ver
\begin_inset CommandInset ref
LatexCommand vref
reference "sub:Param-Example"

\end_inset

.
\end_layout

\begin_layout Subsection
Comodines
\end_layout

\begin_layout Standard
Se puede crear menús que emparejen todos los contenidos de un camino dado.
 En este caso todos los archivos en 
\family typewriter
/static/
\family default
 serán servidos.
 Eso incluye 
\family typewriter
/static/index
\family default
, 
\family typewriter
/static/fruitbat
\family default
, y 
\family typewriter
/static/moose/frog/wombat/meow
\family default
.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

      // Más complejo por que este menú permite que cualquier cosa
\end_layout

\begin_layout Plain Layout

      // dentro de /static sea visible
\end_layout

\begin_layout Plain Layout

      Menu.i("Static") / "static" / **
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nota: Lift no servira ningún archivo o directorio que comience .
 (punto) o _ guión bajo, o que terminen en 
\family typewriter
-hidden
\family default
.
\end_layout

\begin_layout Subsection
Resumen
\end_layout

\begin_layout Standard
Se ha demostrado como crear un 
\family typewriter
SiteMap
\family default
 con diferentes tipos de items de menú.
 A continuación se verá las vistas.
\end_layout

\begin_layout Section
Primero la vista(View First)
\end_layout

\begin_layout Standard
Una vez que el control de acceso es otorgado por el SiteMap, Lift carga
 las vistas relaciondas con la URL.
 Existen varios mecanismos que Lift usa para resolver el camino a una vista,
 pero el más simple es un mapeo uno a uno entre la URL y los archivos que
 estan dentro de 
\family typewriter
/src/main/webapp
\family default
.
 Si la URL es 
\family typewriter
/index
\family default
, entonces Lift buscará la versión localizada (see 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Localization"

\end_inset

) de 
\family typewriter
/src/main/webapp/index.html
\family default
.
 Una vez que Lift carga la plantilla, Lift la procesa y la transforma en
 el contenido dinámico que se quiere devolver en la respuesta a la URL de
 entrada.
\end_layout

\begin_layout Subsection
Código fuente de la página
\end_layout

\begin_layout Standard
Se muestra a continuación el código fuente de la página:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "src/main/webapp/index.html"
lstparams "caption={index.html},language=xml"

\end_inset


\end_layout

\begin_layout Standard
Se puede abrir la página en un navegador:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename raw.png

\end_inset


\end_layout

\begin_layout Subsection
Contenido dinámico
\end_layout

\begin_layout Standard
La plantilla es una página HTML legal(válida).
 Pero existe un marcador en la página para decirle a Lift como interpretar
 el HTML.
\end_layout

\begin_layout Standard
Si la etiqueta 
\family typewriter
<body>
\family default
 contiene un atributo 
\family typewriter
class
\family default
 
\family typewriter
lift:content_id=xxxx
\family default
, entonces Lift buscará el elemento que empareja con el 
\family typewriter
id
\family default
 y lo usará como punto de referencia de inicio para renderizar la página.
 Esto permite a los diseñadores editar y mantener las páginas en la misma
 estructura de directorios que los desarrolladores usan para la aplicación.
\end_layout

\begin_layout Subsection
Surround y page chrome
\end_layout

\begin_layout Standard
El procesamiento de plantillas comienza con:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=xml"
inline false
status open

\begin_layout Plain Layout

 <div id="main" class="lift:surround?with=default&at=content">
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El atributo 
\family typewriter
class
\family default
 
\family typewriter
lift:surround?with=default;at=content
\family default
 instruye a Lift rodear el elemento actual con la plantilla llamada default.html
 (típicamente ubicada en el direcotrio 
\family typewriter
/templates-hidden/
\family default
), y colocar el contenido de la página actual en el elemento con 
\family typewriter
id
\family default
 
\begin_inset Quotes eld
\end_inset

content
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Este patrón nos permite envolver conun cromo en común cada página de nuestro
 sitio.
 Se puede también especificar una plantilla diferente con la cual envolver
 las páginas.
 Adicionalmente, la plantilla misma puede seleccionar diferentes plantillas
 para envolver su contenido.
\end_layout

\begin_layout Subsection
Incrustar
\end_layout

\begin_layout Standard
Adicionalmente a envolver una página con un cromo, se puede incrustar también
 otro archivo.
 Por ejemplo, se puede tener un componente de carrito de compras que se
 incrusta en ciertas páginas.
 Se incrusta de la siguiente forma:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=xml"
inline false
status open

\begin_layout Plain Layout

<span class="lift:embed?what=_embedme">
\end_layout

\begin_layout Plain Layout

  Reemplazado con el contenido incrustado
\end_layout

\begin_layout Plain Layout

</span>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Una vez más, el comando es señalado con un atributo 
\family typewriter
class
\family default
 que comienza con 
\family typewriter
lift:
\family default
.
 En este caso se incustró una plantilla desde el archivo 
\family typewriter
_embedme.html
\family default
.
\end_layout

\begin_layout Subsection
Resultados
\end_layout

\begin_layout Standard
La página generada dinámicamente resultante se parece a:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename browser.png
	width 100col%

\end_inset


\end_layout

\begin_layout Section
Snippets y el contenido dinámico
\end_layout

\begin_layout Standard
Las plantillas en Lift no contienen código ejecutable.
 Son HTML válido puro.
\end_layout

\begin_layout Standard
Lift usa snippets para transformar las secciones de una página HTML de estáticos
 a dinámicos.
\end_layout

\begin_layout Standard
Los snippets de Lift son funciones Scala, de tipo: 
\family typewriter
NodeSeq => NodeSeq
\family default
.
 Un 
\family typewriter
NodeSeq
\family default
 es una colección de nodos XML.
 Un snippet solamente puede transformar una entrada 
\family typewriter
NodeSeq
\family default
 a una salida 
\family typewriter
NodeSeq
\family default
.
 Bueno, no exactamente...
 un snippet puede tambien tener efectos secundarios esto incluye establecer
 cookies, transacciones de la base de datos, etc.
 Esto significa que cada snippet, cada 
\family typewriter
NodeSeq => NodeSeq
\family default
, es un componente.
 Segundo, signfica que las páginas son construidas recursivamente, pero
 permanecen como HTML válido siempre.
 Esto significa que el desarrollador tiene que trabajar mucho para introducir
 una vulnerabilidad cross site scripting.
 Tercero, los diseñadores no tienen que preocuparse por programar algo,
 para diseñar las páginas HTML, debido a que la ejecución del programa es
 abstraida fuera del HTML en lugar de incrustarla dentro del HTML.
\end_layout

\begin_layout Subsection
Snippets y marcado(markup)
\end_layout

\begin_layout Standard
En orden de indicar que el contenido es dinámico, el marcado cotiene una
 invocación a un snippet.
 Que típicamente tiene la forma de
\family typewriter
 class="someclass someothercss lift:mysnippet"
\family default
.
 Si un atributo class contiene 
\family typewriter
lift:xxx
\family default
, el 
\family typewriter
xxx 
\family default
será resuelto a un snippet.
 El snippet puede recibir atributos.
 Los atributos pueden ser codificados como se codifican los parámetros URL...
 precedidos de un 
\family typewriter
?
\family default
 (signo de interrogación), y luego 
\family typewriter
nombre=
\family default
valor, separado por 
\family typewriter
?
\family default
 (signo de interrogación), 
\family typewriter
;
\family default
 (punto y coma) o 
\family typewriter
&
\family default
 (ampersand).
 
\family typewriter
nombre
\family default
 y 
\family typewriter
valor
\family default
 son URL codificada.
\end_layout

\begin_layout Standard
Se puede invocar snippets mediante etiquetas XML:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=xml"
inline false
status open

\begin_layout Plain Layout

<lift:my_snippet cat="foo">
\end_layout

\begin_layout Plain Layout

  <div>xxxx</div>
\end_layout

\begin_layout Plain Layout

</lift:my_snippet>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nota, el parser Html5 obligará a que todas las etiquetas sean minúsculas
 por lo que 
\family typewriter
<lift:MySnipet>
\family default
 se convertirá en 
\family typewriter
<lift:mysnippet>
\family default
.
\end_layout

\begin_layout Standard
En Lift 2.3 se permitirá también otra forma de invocación 
\family typewriter
<div l="mysnippet?param=value">xxx</div>
\family default
.
\end_layout

\begin_layout Standard
Los dos últimos mecanismos para invocar snippets no serán plantillas Html5
 válidas.
\end_layout

\begin_layout Subsection
Resolución de snippets
\end_layout

\begin_layout Standard
En Lift se tiene un sistema muy complejo para resolver de un nombre de snippet
 a un NodeSeq => NodeSeq (ver 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Snippet-Resolution"

\end_inset

).
 Por ahora, el mecanismo más simple es tener una 
\family typewriter
clase
\family default
 u 
\family typewriter
objeto
\family default
 en el paquete 
\family typewriter
snippet
\family default
 que empareje con el nombre del snippet.
\end_layout

\begin_layout Standard
Entonces 
\family typewriter
lift:HelloWorld
\family default
 buscará la clase 
\family typewriter
code.snippet.HelloWorld
\family default
 e invocará el método 
\family typewriter
render
\family default
.
\end_layout

\begin_layout Standard

\family typewriter
lift:CatFood.fruitbat
\family default
 buscará la clase 
\family typewriter
code.snippet.CatFood
\family default
 e invocará el método 
\family typewriter
fruitbat
\family default
.
\end_layout

\begin_layout Subsection
Ejemplo dinámico (Dynamic Example)
\end_layout

\begin_layout Standard
Se ve a continuación la página 
\family typewriter
dynamic.html
\family default
:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "src/main/webapp/dynamic.html"
lstparams "caption={dynamic.html},language=xml"

\end_inset


\end_layout

\begin_layout Standard
Esta plantilla invoca al snippet 
\family typewriter
HelloWorld
\family default
 definido en 
\family typewriter
HelloWorld.scala
\family default
:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "src/main/scala/code/snippet/HelloWorld.scala"
lstparams "caption={HelloWorld.scala}"

\end_inset


\end_layout

\begin_layout Standard
Y el contenido dinámico se convierte en:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=xml"
inline false
status open

\begin_layout Plain Layout

<span>Thu Dec 30 16:31:13 PST 2010</span>
\end_layout

\end_inset


\end_layout

\begin_layout Standard
El código del snippet 
\family typewriter
HelloWorld
\family default
 es simple.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

lazy val date: Box[Date] = DependencyFactory.inject[Date]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Usa inyección de dependencia (dependency injection) (ver 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Dependency-Injection"

\end_inset

) para obtener una instancia de 
\family typewriter
Date
\family default
.
\end_layout

\begin_layout Standard
Entonces:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def render = "* *" #> date.map(_.toString)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Crea un Selector de Transformación CSS (ver 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:CSS-Selector-Transforms"

\end_inset

) que inserta un valor del tipo 
\family typewriter
String
\family default
 de la fecha inyectada (
\family typewriter
Date)
\family default
 en el marcado, en este caso el 
\family typewriter
<span>
\family default
 que invocó al snippet.
\end_layout

\begin_layout Subsection
Ejemplo Incustrado (Embedded Example)
\end_layout

\begin_layout Standard
Se ha visto como se puede incrustrar una plantilla usando: 
\family typewriter
<div class="lift:embed?what=_embedme">xxx</div>
\family default
.
\end_layout

\begin_layout Standard
Se ve a continuación la plantilla 
\family typewriter
_embedme.html
\family default
:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "src/main/webapp/_embedme.html"
lstparams "language=xml"

\end_inset


\end_layout

\begin_layout Standard
Y el programa 
\family typewriter
Embedded.scala
\family default
 invocado:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "src/main/scala/code/snippet/Embedded.scala"
lstparams "caption={Embedded.scala}"

\end_inset


\end_layout

\begin_layout Standard
La plantilla invoca el método 
\family typewriter
from
\family default
 en el snippet 
\family typewriter
Embedded
\family default
.
 En este caso el snippet es un 
\family typewriter
objeto
\family default
 singleton porque no contiene ningún parámetro de construcción y no tiene
 variable de instancia.
\end_layout

\begin_layout Standard
El método 
\family typewriter
from
\family default
:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

  def from = "*" #> S.location.map(_.name)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Crea un Selector de Transformación CSS que reemplaza los contenidos del
 
\family typewriter
name
\family default
 del 
\family typewriter
location
\family default
 actual.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Param-Example"

\end_inset

Ejemplo Param (Param Example)
\end_layout

\begin_layout Standard
Arriba se ha visto como crear un 
\family typewriter
Loc[ParamInfo]
\family default
 para capturar los parámetros del URL.
 Si se ve la página 
\family typewriter
/param/xxx
\family default
 y se ve como se puede acceder a los parámetros:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "src/main/webapp/param.html"
lstparams "caption={param.html},language=xml"

\end_inset


\end_layout

\begin_layout Standard
Se ve a continuación dos snippets diferentes que pueden acceder a 
\family typewriter
ParamInfo
\family default
 para la página:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "src/main/scala/code/snippet/Param.scala"
lstparams "caption={Param.scala}"

\end_inset


\end_layout

\begin_layout Standard
Cada snippet tiene un método 
\family typewriter
render
\family default
.
 Sin embargo, la clase 
\family typewriter
ShowParam
\family default
 toma un constructor de parámetro que contiene el 
\family typewriter
ParamInfo
\family default
 para el 
\family typewriter
Loc[_]
\family default
 actual.
 Si el 
\family typewriter
Loc
\family default
 actual no tiene un parámetro de tipo 
\family typewriter
ParamInfo
\family default
, no se creará ninguna instancia de 
\family typewriter
ShowParam
\family default
 y el snippet no podrá ser resuelto.
 Pero si se tiene un Loc[ParamInfo], asi que Lift construye un 
\family typewriter
ShowParam
\family default
 con el valor actual del 
\family typewriter
Loc
\family default
 y luego el método 
\family typewriter
render
\family default
 es invocado y devuelve un Selector de Transformación CSS que es un
\family typewriter
 NodeSeq => NodeSeq
\family default
.
\end_layout

\begin_layout Standard
El método 
\family typewriter
render del
\family default
 
\family typewriter
objeto Param
\family default
 accede al 
\family typewriter
Loc[ParamInfo]
\family default
 directamente.
 El método 
\family typewriter
render
\family default
 obtiene el valro actual del 
\family typewriter
Loc
\family default
 y lo usa para calcular el valor a devolver, el Selector de Transformación
 CSS.
\end_layout

\begin_layout Subsection
Recursivo
\end_layout

\begin_layout Standard
Los snippets en Lift son evaluados perezosamente.
 Esto quiere decir que el cuerpo del snippet no es ejecutado hasta que el
 snippet exterior es ejecutado, lo que permite devolver marcado de un snippet
 que a su vez contiene otro snippet o alternativamente, seleccionar una
 parte del cuerpo del snippet que en si contiene una invocación a un snippet.
 Por ejemplo:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "src/main/webapp/recurse.html"
lstparams "caption={recurse.html},language=xml"

\end_inset


\end_layout

\begin_layout Standard
El snippet 
\family typewriter
Recurse
\family default
 selecciona uno de los dos 
\family typewriter
<div>
\family default
's, cada uno de los cuales invoca a un snippet por si mismo.
 A continuación el archivo Scala:
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand lstinputlisting
filename "src/main/scala/code/snippet/Recurse.scala"
lstparams "caption={Recurse.scala}"

\end_inset


\end_layout

\begin_layout Standard
Dependiendo el valor de 
\family typewriter
which
\family default
, uno o las dos partes del marcado seran seleccionadas.
 Y cada parte del amrcado ensi invocará a un snippet que mostrará un mensaje
 y pasará el marcado.
\end_layout

\begin_layout Standard
Usando esta técnica, se puede tener un snippet que selecciona uno o muchos
 snippets o que devuelve un snippet 
\family typewriter
lift:embed
\family default
, lo que permite una generación muy dinámica de marcado.
\end_layout

\begin_layout Subsection
Resumen
\end_layout

\begin_layout Standard
Se ha visto algunos ejemplos de los mecanismos que Lift usa para generar
 contenido dinámico.
 Se puede leer más sobre snippets (ver 
\begin_inset CommandInset ref
LatexCommand vref
reference "sec:Snippets"

\end_inset

).
\end_layout

\begin_layout Section
Envolver (Wrap up)
\end_layout

\begin_layout Standard
En este capítulo, se ha visto como definir el comportamiento de la aplicación
 en 
\family typewriter
Boot.scala
\family default
.
 Hemos explorado el 
\family typewriter
SiteMap
\family default
 de Lift que es usado para generar navegación y que hace cumplir el control
 de acceso.
 Se ha visto como el sistemade plantillas de Lift trabaja (bueno, existen
 un montón de maneras de manejar plantillas en Lift, pero se ha explorado
 el mecanismo más común).
 Se ha visto como es que los snippets trabajan.
\end_layout

\begin_layout Standard
En el siguiente capítulo, se sumergirá en la manipulación de formularios
 en Lift.
\end_layout

\end_body
\end_document
